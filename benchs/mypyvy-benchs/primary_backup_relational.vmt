(declare-sort data 0)
(declare-const zero data)
(define-fun zero.sv () data (! zero :rigid true))
(declare-fun le (data data) Bool)
(declare-fun _0__primary (data) Bool)
(declare-fun _1__primary (data) Bool)
(define-fun _0__primary.sv ((V0 data)) Bool (! (_0__primary V0) :next _1__primary))
(declare-fun _0__backup (data) Bool)
(declare-fun _1__backup (data) Bool)
(define-fun _0__backup.sv ((V0 data)) Bool (! (_0__backup V0) :next _1__backup))
(declare-fun _0__msg (data) Bool)
(declare-fun _1__msg (data) Bool)
(define-fun _0__msg.sv ((V0 data)) Bool (! (_0__msg V0) :next _1__msg))
(define-fun axiom_0 () Bool (! (forall ((X_0 data)) (le X_0 X_0)) :axiom true))
(define-fun axiom_1 () Bool (! (forall ((X_1 data) (Y_2 data))
  (=> (and (le X_1 Y_2) (le Y_2 X_1)) (= X_1 Y_2))) :axiom true))
(define-fun axiom_2 () Bool (! (forall ((X_3 data) (Y_4 data) (Z_5 data))
  (=> (and (le X_3 Y_4) (le Y_4 Z_5)) (le X_3 Z_5))) :axiom true))
(define-fun axiom_3 () Bool (! (forall ((X_6 data) (Y_7 data)) (or (le X_6 Y_7) (le Y_7 X_6))) :axiom true))
(define-fun axiom_4 () Bool (! (forall ((X_8 data)) (le zero X_8)) :axiom true))
(define-fun init () Bool (! (and (forall ((X_0 data)) (= (_0__primary X_0) (= X_0 zero)))
     (forall ((X_1 data)) (= (_0__backup X_1) (= X_1 zero)))
     (forall ((X_2 data)) (not (_0__msg X_2)))) :init true))
(define-fun transition_0 () Bool (! (exists ((x_0 data))
  (let ((a!1 (forall ((X_1 data))
               (= (_1__msg X_1) (or (_0__msg X_1) (= X_1 x_0))))))
    (and (_0__primary x_0)
         a!1
         (forall ((x0_2 data)) (= (_1__primary x0_2) (_0__primary x0_2)))
         (forall ((x0_3 data)) (= (_1__backup x0_3) (_0__backup x0_3)))))) :action true))
(define-fun transition_1 () Bool (! (exists ((x_4 data))
  (let ((a!1 (forall ((X_6 data))
               (= (_1__msg X_6) (and (_0__msg X_6) (distinct X_6 x_4))))))
    (and (_0__msg x_4)
         (forall ((X_5 data)) (= (_1__backup X_5) (= X_5 x_4)))
         a!1
         (forall ((x0_7 data)) (= (_1__primary x0_7) (_0__primary x0_7)))))) :action true))
(define-fun transition_2 () Bool (! (exists ((current_8 data) (next_9 data))
  (and (_0__primary current_8)
       (le current_8 next_9)
       (forall ((X_10 data)) (= (_1__primary X_10) (= X_10 next_9)))
       (forall ((x0_11 data)) (= (_1__backup x0_11) (_0__backup x0_11)))
       (forall ((x0_12 data)) (= (_1__msg x0_12) (_0__msg x0_12))))) :action true))
(define-fun safety-prop () Bool (!(and (exists ((X_0 data) (Y_1 data))
       (and (_0__primary X_0) (_0__backup Y_1) (le Y_1 X_0)))) :invar-property 0))
(define-fun invariant_0 () Bool (! (exists ((X_0 data) (Y_1 data))
  (and (_0__primary X_0) (_0__backup Y_1) (le Y_1 X_0))) :invar-property 0))
